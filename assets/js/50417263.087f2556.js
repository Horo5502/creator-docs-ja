"use strict";(self.webpackChunkVRChat_Creator_Docs=self.webpackChunkVRChat_Creator_Docs||[]).push([[9787],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var r=n(96540);const a={},o=r.createContext(a);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:t},e.children)}},61278:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"worlds/udon/data-containers/byte-and-bit-operations","title":"Byte and Bit Operations","description":"This page describes lower level concepts of working with binary data and is intended for advanced creators.","source":"@site/docs/worlds/udon/data-containers/byte-and-bit-operations.md","sourceDirName":"worlds/udon/data-containers","slug":"/worlds/udon/data-containers/byte-and-bit-operations","permalink":"/creator-docs_ja/worlds/udon/data-containers/byte-and-bit-operations","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1722644343000,"sidebarPosition":10,"frontMatter":{"title":"Byte and Bit Operations","slug":"byte-and-bit-operations","hidden":false,"sidebar_position":10,"createdAt":"2024-02-26T18:00:00.000Z","updatedAt":"2024-02-26T18:00:00.000Z"},"sidebar":"tutorialSidebar","previous":{"title":"Data Containers","permalink":"/creator-docs_ja/worlds/udon/data-containers/"},"next":{"title":"Data Dictionaries","permalink":"/creator-docs_ja/worlds/udon/data-containers/data-dictionaries"}}');var a=n(74848),o=n(28453);const i={title:"Byte and Bit Operations",slug:"byte-and-bit-operations",hidden:!1,sidebar_position:10,createdAt:"2024-02-26T18:00:00.000Z",updatedAt:"2024-02-26T18:00:00.000Z"},s="Byte and Bit Operations",l={},u=[{value:"Example Code",id:"example-code",level:2}];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"byte-and-bit-operations",children:"Byte and Bit Operations"})}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:"This page describes lower level concepts of working with binary data and is intended for advanced creators."})}),"\n",(0,a.jsxs)(t.p,{children:["You can use the ",(0,a.jsx)(t.code,{children:"Bitcast"}),' method on DataTokens to do value-preserving type changes ("unsafe casts") on primitive data types in Udon.']}),"\n",(0,a.jsxs)(t.p,{children:["Some standard C# classes for operating on raw binary data are also available, including ",(0,a.jsx)(t.code,{children:"BitConverter"})," and ",(0,a.jsx)(t.code,{children:"Buffer"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"example-code",children:"Example Code"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",metastring:'title="Byte and Bit Operations Example, Basic Serializer"',children:'using System;\r\nusing System.Text;\r\nusing UdonSharp;\r\nusing UnityEngine;\r\nusing VRC.SDK3.Data;\r\n\r\npublic class BitConverterExample : UdonSharpBehaviour\r\n{\r\n    void Start()\r\n    {\r\n        //Create test data\r\n        int originalInt = 63;\r\n        double originalDouble = 734531.433d;\r\n        string originalString = "Test string";\r\n        float[] originalFloatArray = new float[] { 543, 12.6f, 63.1231f };\r\n\r\n        //Serialize and then deserialize\r\n        byte[] serialized = Serialize(originalInt, originalDouble, originalString, originalFloatArray);\r\n        Deserialize(serialized, out int newInt, out double newDouble, out string newString, out float[] newFloatArray); \r\n        \r\n        //Print the results to see if everything matches\r\n        Debug.Log($"{originalInt} - {newInt}");\r\n        Debug.Log($"{originalDouble} - {newDouble}");\r\n        Debug.Log($"{originalString} - {newString}");\r\n        Debug.Log($"{originalFloatArray.Length} - {newFloatArray.Length}");\r\n        for (int i = 0; i < originalFloatArray.Length && i < newFloatArray.Length; i++)\r\n        {\r\n            Debug.Log($"{originalFloatArray[i]} - {newFloatArray[i]}");\r\n        }\r\n\r\n        //For individual values we can also use DataToken Bitcasting to get bit access\r\n        double doubleValue = 123.456d;\r\n        DataToken doubleToken = new DataToken(doubleValue);\r\n        //We used ulong because it has the same size as a double (8 bytes)\r\n        DataToken ulongToken = doubleToken.Bitcast(TokenType.ULong);\r\n        DataToken resultDoubleToken = ulongToken.Bitcast(TokenType.Double);\r\n        Debug.Log($"{doubleToken} - 0x{ulongToken:02X} - {resultDoubleToken}");\r\n    }\r\n\r\n    /// <summary>\r\n    /// An example function which serializes a pre-determined set of data into a byte array\r\n    /// </summary>\r\n    /// <param name="intValue">Integer which will be encoded into the output</param>\r\n    /// <param name="doubleValue">Double which will be encoded into the output</param>\r\n    /// <param name="stringValue">String which will be encoded into the output</param>\r\n    /// <param name="floatArrayValues">Float array which will be encoded into the output</param>\r\n    /// <returns></returns>\r\n    byte[] Serialize(int intValue, double doubleValue, string stringValue, float[] floatArrayValues)\r\n    {\r\n        int size = 0;\r\n        byte[] intBytes = BitConverter.GetBytes(intValue); //Convert int to bytes\r\n        size += intBytes.Length;\r\n        \r\n        byte[] doubleBytes = BitConverter.GetBytes(doubleValue); //Convert int to bytes\r\n        size += doubleBytes.Length;\r\n        \r\n        byte[] stringBytes = Encoding.UTF8.GetBytes(stringValue); //Convert string to bytes\r\n        size += stringBytes.Length;\r\n        Debug.Log($"String byte length {stringBytes.Length}");\r\n        \r\n        byte[] stringLengthBytes = BitConverter.GetBytes(stringBytes.Length); //Convert string length to bytes\r\n        size += stringLengthBytes.Length;\r\n        \r\n        byte[] floatArrayLengthBytes = BitConverter.GetBytes(Buffer.ByteLength(floatArrayValues));\r\n        size += floatArrayLengthBytes.Length;\r\n        \r\n        //It is not necessary to convert the float array into a byte array because we can BlockCopy it directly\r\n        size += Buffer.ByteLength(floatArrayValues);\r\n\r\n        byte[] output = new byte[size]; //Allocate an array of the correct size that should fit all of our items\r\n        int offset = 0;\r\n\r\n        Buffer.BlockCopy(intBytes, 0, output, offset, intBytes.Length); //Write int - this should take up 4 bytes\r\n        offset += intBytes.Length; //Increment offset so the next item can write to the correct location\r\n        \r\n        Buffer.BlockCopy(doubleBytes, 0, output, offset, doubleBytes.Length); //Write double - this should take up 8 bytes\r\n        offset += doubleBytes.Length;\r\n        \r\n        Buffer.BlockCopy(stringLengthBytes, 0, output, offset, stringLengthBytes.Length); //Write the length of the string so the decoder knows how much to decode - this should take up 4 bytes\r\n        offset += stringLengthBytes.Length;\r\n\r\n        Buffer.BlockCopy(stringBytes, 0, output, offset, stringBytes.Length); //Write string - this is variable, which is why we need to encode the length of the string above\r\n        offset += stringBytes.Length;\r\n\r\n        Buffer.BlockCopy(floatArrayLengthBytes, 0, output, offset, floatArrayLengthBytes.Length); //Write the length of the float array so the decoder knows how much to decode - this should take up 4 bytes\r\n        offset += floatArrayLengthBytes.Length;\r\n        \r\n        Buffer.BlockCopy(floatArrayValues, 0, output, offset, Buffer.ByteLength(floatArrayValues)); //Write float array - this can be done directly without a byte array conversion because it\'s already an Array\r\n        offset += Buffer.ByteLength(floatArrayValues);\r\n        \r\n        Debug.Log($"Encoded data in {output.Length} bytes");\r\n        return output;\r\n    }\r\n\r\n    /// <summary>\r\n    /// An example function which deserializes a pre-determined set of data described in the Serialize function above\r\n    /// </summary>\r\n    /// <param name="input">Input bytes - must be formatted in the expected manner by the Serialize function above</param>\r\n    /// <param name="intValue">Output int value deserialized from the data inside the input</param>\r\n    /// <param name="doubleValue">Output double value deserialized from the data inside the input</param>\r\n    /// <param name="stringValue">Output string value deserialized from the data inside the input</param>\r\n    /// <param name="floatArrayValues">Output float array value deserialized from the data inside the input</param>\r\n    /// <returns></returns>\r\n    bool Deserialize(byte[] input, out int intValue, out double doubleValue, out string stringValue, out float[] floatArrayValues)\r\n    {\r\n        int offset = 0;\r\n        \r\n        intValue = BitConverter.ToInt32(input, offset);\r\n        offset += 4; //Increment the offset so the next item reads from the correct location. Ints should be 4 bytes long\r\n        \r\n        doubleValue = BitConverter.ToDouble(input, offset);\r\n        offset += 8; //Doubles should be 8 bytes long\r\n        \r\n        int stringLength = BitConverter.ToInt32(input, offset);\r\n        offset += 4; //String length is an int, which should be 4 bytes long\r\n        \r\n        Debug.Log($"Decoding string length {stringLength} at offset {offset} for buffer length {input.Length}");\r\n        stringValue = Encoding.UTF8.GetString(input, offset, stringLength);\r\n        offset += stringLength; //Strings are variable length\r\n\r\n        int floatArrayByteLength = BitConverter.ToInt32(input, offset);\r\n        offset += 4; //Float array length is an int, which should be 4 bytes long\r\n        \r\n        floatArrayValues = new float[floatArrayByteLength / 4]; //Create a new float array of the correct size to receive the data\r\n        Buffer.BlockCopy(input, offset, floatArrayValues, 0, floatArrayByteLength); //Copy the data from the input into the float array\r\n        \r\n        return true;\r\n    }\r\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);