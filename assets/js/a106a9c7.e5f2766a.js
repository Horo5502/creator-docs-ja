"use strict";(self.webpackChunkVRChat_Creator_Docs=self.webpackChunkVRChat_Creator_Docs||[]).push([[3023],{28453:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>i});var s=r(96540);const n={},a=s.createContext(n);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},93031:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"worlds/examples/obstacle-course/uoc-how-stuff-works","title":"Obstacle Course: How Stuff Works","description":"Each system was designed to have a specific set of responsibilities, and to know about other systems as little as necessary.","source":"@site/docs/worlds/examples/obstacle-course/uoc-how-stuff-works.md","sourceDirName":"worlds/examples/obstacle-course","slug":"/worlds/examples/obstacle-course/uoc-how-stuff-works","permalink":"/creator-docs_ja/worlds/examples/obstacle-course/uoc-how-stuff-works","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1685478715000,"frontMatter":{"title":"Obstacle Course: How Stuff Works","slug":"uoc-how-stuff-works","excerpt":"How all the different programs and custom editor scripts work together in the Udon Obstacle Course","hidden":false,"createdAt":"2021-08-10T19:42:13.400Z","updatedAt":"2021-08-18T20:57:54.974Z"},"sidebar":"tutorialSidebar","previous":{"title":"Obstacle Course: Flythrough","permalink":"/creator-docs_ja/worlds/examples/obstacle-course/uoc-flythrough"},"next":{"title":"Obstacle Course Toolkit","permalink":"/creator-docs_ja/worlds/examples/obstacle-course/uoc-window"}}');var n=r(74848),a=r(28453);const o={title:"Obstacle Course: How Stuff Works",slug:"uoc-how-stuff-works",excerpt:"How all the different programs and custom editor scripts work together in the Udon Obstacle Course",hidden:!1,createdAt:"2021-08-10T19:42:13.400Z",updatedAt:"2021-08-18T20:57:54.974Z"},i="Overview",h={},l=[{value:"PlayerDataManager",id:"playerdatamanager",level:2},{value:"PlayerObject",id:"playerobject",level:2},{value:"PlayerData",id:"playerdata",level:2},{value:"OnPlayerDataEnter",id:"onplayerdataenter",level:2},{value:"ObstacleCourseData",id:"obstaclecoursedata",level:2},{value:"Checkpoint",id:"checkpoint",level:2},{value:"ScoreManager",id:"scoremanager",level:2},{value:"ScoreField",id:"scorefield",level:2},{value:"HighScoreField",id:"highscorefield",level:2},{value:"PlayerModsManager",id:"playermodsmanager",level:2},{value:"DestroyAfterXSeconds",id:"destroyafterxseconds",level:2},{value:"PlayClipFromArray",id:"playclipfromarray",level:2},{value:"Autorotate",id:"autorotate",level:2},{value:"SpawnedHazard",id:"spawnedhazard",level:2},{value:"HazardSpawner",id:"hazardspawner",level:2},{value:"FallingBlock",id:"fallingblock",level:2},{value:"Injection",id:"injection",level:2}];function c(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Each system was designed to have a specific set of responsibilities, and to know about other systems as little as necessary."}),"\n",(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"overview",children:"Overview"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.strong,{children:"PlayerDataManager"})," assigns ",(0,n.jsx)(t.strong,{children:"PlayerData"})," objects to each player who enters the world."]}),"\n",(0,n.jsxs)(t.li,{children:["When a ",(0,n.jsx)(t.strong,{children:"PlayerData"})," object enters the Start Gate ",(0,n.jsx)(t.strong,{children:"Checkpoint"}),", the ",(0,n.jsx)(t.strong,{children:"Course"})," they just entered starts tracking their time, and activates the next ",(0,n.jsx)(t.strong,{children:"Checkpoint"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["When the ",(0,n.jsx)(t.strong,{children:"PlayerData"})," object passes through the last ",(0,n.jsx)(t.strong,{children:"Checkpoint"}),", their time is added to the Scoreboard."]}),"\n",(0,n.jsxs)(t.li,{children:["If the ",(0,n.jsx)(t.strong,{children:"PlayerData"})," object enters a ",(0,n.jsx)(t.strong,{children:"PowerUp"})," trigger, the ",(0,n.jsx)(t.strong,{children:"PlayerModsManager"})," temporarily changes their speed and/or jump abilities, resetting them to default after a set duration"]}),"\n",(0,n.jsxs)(t.li,{children:["If the ",(0,n.jsx)(t.strong,{children:"PlayerData"})," object enters a ",(0,n.jsx)(t.strong,{children:"Respawn"})," trigger, the ",(0,n.jsx)(t.strong,{children:"Course"})," will respawn them at the last ",(0,n.jsx)(t.strong,{children:"Checkpoint"})," through which they passed."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The following sections describe the programs and scripts that combine to make the whole experience."}),"\n",(0,n.jsx)(t.h1,{id:"players",children:"Players"}),"\n",(0,n.jsxs)(t.p,{children:["Each player who joins the world gets a 'PlayerData' object to manage their state and progress through a course. The ",(0,n.jsx)(t.strong,{children:"PlayerDataManager"})," assigns ",(0,n.jsx)(t.strong,{children:"PlayerData"})," objects, which can trigger ",(0,n.jsx)(t.strong,{children:"OnPlayerDataEnter"})," programs."]}),"\n",(0,n.jsx)(t.h2,{id:"playerdatamanager",children:"PlayerDataManager"}),"\n",(0,n.jsxs)(t.p,{children:['You can find this program on the "PlayerDataManager" GameObject under the "Udon" object in the scene. It has two important public variables:\r\n',(0,n.jsx)(t.strong,{children:"dataPool"}),": Reference to the VRC Object Pool component on the same object as this Manager. When a Player Joins the world, this manager will TryToSpawn a PlayerData object for them, and give them ownership.\r\n",(0,n.jsx)(t.strong,{children:"followCam"}),": Reference to the camera that will follow above a Player as they run through the course. Set here so the PlayerDataManager can assign the reference to each PlayerData object when they are refreshed."]}),"\n",(0,n.jsx)(t.p,{children:"When you change the 'Number of Players' option in the Toolkit Window, all the existing PlayerData objects will be removed from the scene, then new copies of them will be added as children of the PlayerDataManager. Each one will have its public variables set up properly, and the Object Pool will be updated to hold all the new PlayerData objects."}),"\n",(0,n.jsx)(t.h2,{id:"playerobject",children:"PlayerObject"}),"\n",(0,n.jsxs)(t.p,{children:["The PlayerObject prefab has a Rigidbody and Capsule Collider component, which are needed to trigger PowerUps, Hazards, etc. It's on a custom layer ",(0,n.jsx)(t.strong,{children:"CoursePlayer"})," which only collides with ",(0,n.jsx)(t.strong,{children:"CourseTrigger"})," to interact with Hazards and PowerUps. It also has an UdonBehaviour with an important program on it:"]}),"\n",(0,n.jsx)(t.h2,{id:"playerdata",children:"PlayerData"}),"\n",(0,n.jsxs)(t.p,{children:["This program is the main connector between the player running the course and all the other systems. Its variables are:\r\n",(0,n.jsx)(t.strong,{children:"timeElapsed"}),": Synced Float which is updated by the ",(0,n.jsx)(t.strong,{children:"Course"})," program when they cross the Finish Gate. When it changes, the owner of the PlayerData object will show this time on the scoreboard so they can see their latest time locally. The owner of the ScoreManager object will see this change and add the new time and displayName of the Player to the scoreboard."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"isRacing"}),": Boolean which is set true by the ",(0,n.jsx)(t.strong,{children:"Course"})," when the player has entered a start gate. It's set to false when the player enters a finish gate, manually respawns using their menu, or ",(0,n.jsx)(t.strong,{children:"Reset"})," is called on the ",(0,n.jsx)(t.strong,{children:"Course"}),". Used by the ",(0,n.jsx)(t.strong,{children:"Course"}),", see that program for more info."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"rigidbody"}),": Cached on Start by the program, it doesn't need to be set in the inspector. It's moved to the position and rotation of the player during every Update."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"player"}),": Reference to the actual VRCPlayerApi object of the local player. Cached when the synced ",(0,n.jsx)(t.em,{children:"playerId"})," on this program is changed. Used to retrieve the ",(0,n.jsx)(t.em,{children:"displayName"})," of the player."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"timeDisplay"}),": Reference to the UdonBehaviour which displays the latest time for the local player."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"scoreManager"}),": Reference to the ",(0,n.jsx)(t.strong,{children:"ScoreManager"})," UdonBehaviour. When the owner of that object receives a ",(0,n.jsx)(t.em,{children:"timeElapsed"})," change from a ",(0,n.jsx)(t.strong,{children:"PlayerData"})," object which just finished the course, it sets the public variable ",(0,n.jsx)(t.em,{children:"scoreToProcess"})," on the ",(0,n.jsx)(t.strong,{children:"ScoreManager"})," object to a string which combines the ",(0,n.jsx)(t.em,{children:"displayName"})," and ",(0,n.jsx)(t.em,{children:"elapsedTime"})," into a single string to be processed."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"scoreManagerObject"}),": Reference to the GameObject which holds the UdonBehaviour with the ",(0,n.jsx)(t.strong,{children:"ScoreManager"})," program. Needed to ensure we only run the Score Processing logic on the owner of the ",(0,n.jsx)(t.strong,{children:"ScoreManager"})," object. We can't get this GameObject from an UdonBehaviour reference, so we include it here."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"followCam"}),": Reference to the CinemachineVirtualCamera which follows the player around the course. The program sets its own Transform as both the ",(0,n.jsx)(t.em,{children:"follow"})," and ",(0,n.jsx)(t.em,{children:"lookAt"})," targets for the camera, and changes the priority on this camera when ",(0,n.jsx)(t.em,{children:"isRacing"})," changes."]}),"\n",(0,n.jsx)(t.h2,{id:"onplayerdataenter",children:"OnPlayerDataEnter"}),"\n",(0,n.jsxs)(t.p,{children:["This program is used on objects which should detect the ",(0,n.jsx)(t.strong,{children:"PlayerData"})," object entering its Trigger Collider. We use the custom layers ",(0,n.jsx)(t.strong,{children:"CoursePlayer"})," and ",(0,n.jsx)(t.strong,{children:"CourseTrigger"})," ensure that only certain objects will trigger this collider. When they do, it fires the internal event ",(0,n.jsx)(t.strong,{children:"OnPlayerDataEnter"})," to do a multitude of things. This program has the following variables:"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"fxPrefab"}),": A GameObject to spawn when on ",(0,n.jsx)(t.strong,{children:"Trigger"}),", meant to play a sound, show some particles, etc so the Player knows that something has happened."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"program"}),": A target UdonBehaviour with an event we want to run on ",(0,n.jsx)(t.strong,{children:"Trigger"}),". This ",(0,n.jsx)(t.em,{children:"program"})," contains the specific logic for a ",(0,n.jsx)(t.strong,{children:"Checkpoint"}),", ",(0,n.jsx)(t.strong,{children:"PowerUp"}),", ",(0,n.jsx)(t.strong,{children:"Hazard"}),", etc."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"eventName"}),": The event name to run on the target ",(0,n.jsx)(t.em,{children:"program"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"deactivateOnTrigger"}),": Whether this object should deactivate itself after a single ",(0,n.jsx)(t.strong,{children:"Trigger"}),". This is useful for ",(0,n.jsx)(t.strong,{children:"Checkpoints"})," and other items that should only activate once per run."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"lastCollider"}),": Collider which started the Trigger logic, which is temporarily cached before ",(0,n.jsx)(t.strong,{children:"Trigger"})," is called and used to find the ",(0,n.jsx)(t.strong,{children:"PlayerData"})," UdonBehaviour if needed."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"fxSpawn"}),": A Transform we use to set the position of the FX we will spawn. Defaults to the Transform of the object with the collider if not set, useful if you want to trigger Fireworks in another location when running through a collider, like we do for the Finish Gate."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"sendPlayerData"}),": A Boolean that decides whether or not to try to pass along the ",(0,n.jsx)(t.strong,{children:"PlayerData"})," program that Triggered the logic. Used when entering a Start Gate, could be useful for other things as well."]}),"\n",(0,n.jsxs)(t.p,{children:["When a ",(0,n.jsx)(t.strong,{children:"PlayerData"})," collider trigger entry is detected, this program does the following:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["If we have set an ",(0,n.jsx)(t.em,{children:"eventName"})," variable, then we will check whether ",(0,n.jsx)(t.em,{children:"sendPlayerData"})," is true. If it is, we will try to set the ",(0,n.jsx)(t.em,{children:"playerData"})," variable on the target UdonBehaviour program to the UdonBehaviour with which we just collided."]}),"\n",(0,n.jsxs)(t.li,{children:["We will then run the event ",(0,n.jsx)(t.em,{children:"eventName"})," on the target program."]}),"\n",(0,n.jsxs)(t.li,{children:["If the ",(0,n.jsx)(t.em,{children:"fxPrefab"})," GameObject on this program was set (not left at default of 'self'), then we will ",(0,n.jsx)(t.strong,{children:"Instantiate"})," a copy of the prefab and set its position and rotation from the ",(0,n.jsx)(t.em,{children:"fxSpawn"})," variable."]}),"\n",(0,n.jsxs)(t.li,{children:["If ",(0,n.jsx)(t.em,{children:"deactivateOnTrigger"})," is true, then we will set ",(0,n.jsx)(t.strong,{children:"this"})," GameObject to inactive."]}),"\n"]}),"\n",(0,n.jsx)(t.h1,{id:"course--checkpoints",children:"Course & Checkpoints"}),"\n",(0,n.jsx)(t.p,{children:"This is the heart of the project, the gates and checkpoints that you need to move through to complete the time trial."}),"\n",(0,n.jsx)(t.h1,{id:"course",children:"Course"}),"\n",(0,n.jsx)(t.p,{children:"This program lives on the CourseManager object and manages the state of the time trial for the local player. It doesn't have any synced variables - it only knows about the Local Player who is running through it."}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"Start"}),", it calls ",(0,n.jsx)(t.strong,{children:"Reset"})," to set itself up properly.\r\nIf the player Respawns themselves, the Course will ",(0,n.jsx)(t.strong,{children:"Reset"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"Reset"}),", we turn off all of the ",(0,n.jsx)(t.strong,{children:"Checkpoint"})," triggers except for the Start Gate, which we turn on. We do this by looping through each GameObject in the ",(0,n.jsx)(t.em,{children:"checkpoints"})," array, finding every Trigger Collider, and calling ",(0,n.jsx)(t.strong,{children:"SetActive"})," on that collider's GameObject to true for index 0 and false for all the others.\r\nWe also set ",(0,n.jsx)(t.em,{children:"nextIndex"})," to -1 and set ",(0,n.jsx)(t.em,{children:"isRacing"})," to false."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"StartRace"}),", we:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["set ",(0,n.jsx)(t.em,{children:"startTime"})," from the current time"]}),"\n",(0,n.jsxs)(t.li,{children:["set ",(0,n.jsx)(t.em,{children:"isRacing"})," to true"]}),"\n",(0,n.jsxs)(t.li,{children:["set ",(0,n.jsx)(t.em,{children:"nextIndex"})," to 1 (since the race is started by passing through Checkpoint 0)"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["When a ",(0,n.jsx)(t.strong,{children:"Checkpoint"})," is triggered, it sets the ",(0,n.jsx)(t.em,{children:"nextIndex"})," on the Course to its own index + 1. This triggers the ",(0,n.jsx)(t.strong,{children:"nextIndexChange"})," event on the Course program, which will then activate the GameObject for the next Checkpoint."]}),"\n",(0,n.jsxs)(t.p,{children:["During ",(0,n.jsx)(t.strong,{children:"Update"}),", we check whether a player ",(0,n.jsx)(t.em,{children:"isRacing"}),", and if so we get the elapsed time of the run and set it on the ",(0,n.jsx)(t.em,{children:"timeDisplay"})," Text object."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"FinishRace"}),", we:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["set ",(0,n.jsx)(t.em,{children:"isRacing"})," to false"]}),"\n",(0,n.jsxs)(t.li,{children:["set ",(0,n.jsx)(t.em,{children:"timeElapsed"})," on the target ",(0,n.jsx)(t.strong,{children:"PlayerData"})," program to the current time minus ",(0,n.jsx)(t.em,{children:"startTime"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["set ",(0,n.jsx)(t.em,{children:"playerData"})," to null since we no longer have a player running the course."]}),"\n",(0,n.jsxs)(t.li,{children:["wait for ",(0,n.jsx)(t.em,{children:"resetDelay"})," seconds and then ",(0,n.jsx)(t.strong,{children:"Reset"})," the course."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"Respawn"}),", we check whether the player ",(0,n.jsx)(t.em,{children:"isRacing"}),". If so, we send them back to the transform position of the last checkpoint. If not, we teleport them down low enough that they will be respawned by the world, back at one of the original spawn points."]}),"\n",(0,n.jsx)(t.h2,{id:"obstaclecoursedata",children:"ObstacleCourseData"}),"\n",(0,n.jsxs)(t.p,{children:["This custom script just holds a reference to the ",(0,n.jsx)(t.strong,{children:"ObstacleCourseAsset"})," with all the info about your course like which prefabs to use, the number of players, the default speeds, etc. It's loaded by the Utility Window so you should have one in your scene. You should create your own so it's not overwritten if you update your project with a newer version of this package. Do this by duplicating an existing asset, which will ensure the default values are correct."]}),"\n",(0,n.jsx)(t.h2,{id:"checkpoint",children:"Checkpoint"}),"\n",(0,n.jsxs)(t.p,{children:["The Checkpoint objects each have an index which represents their order in the time trial, this is automatically set when placing Checkpoints through the Utility Window or modifying their order.\r\nThey have a Trigger Collider with an ",(0,n.jsx)(t.strong,{children:"OnPlayerDataEnter"})," program which call into a ",(0,n.jsx)(t.strong,{children:"Checkpoint"}),' program that we have on an object called "UdonProgram" in our example prefabs. The program is simple, with three possible events that can be triggered on it:']}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"StartRace"})," will set the ",(0,n.jsx)(t.em,{children:"playerData"})," variable on the ",(0,n.jsx)(t.strong,{children:"Course"})," program to the UdonBehaviour that just entered this checkpoint. The Course will start the race when that happens."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Trigger"})," will set the ",(0,n.jsx)(t.em,{children:"nextIndex"})," variable on the ",(0,n.jsx)(t.strong,{children:"Course"})," program to the ",(0,n.jsx)(t.em,{children:"index"})," + 1."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"FinishRace"})," will simply call ",(0,n.jsx)(t.strong,{children:"FinishRace"})," on the ",(0,n.jsx)(t.strong,{children:"Course"})," program."]}),"\n",(0,n.jsx)(t.h1,{id:"score",children:"Score"}),"\n",(0,n.jsx)(t.p,{children:"What's a time trial without some friendly competition? The Score system syncs the names and times of the latest runs, as well as the best run so far in the instance."}),"\n",(0,n.jsx)(t.h2,{id:"scoremanager",children:"ScoreManager"}),"\n",(0,n.jsxs)(t.p,{children:['This program sits on an Object called "ScoreManager" under the "Udon" GameObject. It uses a queue system to process incoming scores and sync them. It doesn\'t actually have ',(0,n.jsx)(t.em,{children:"any synced variables"})," itself, relying on the ",(0,n.jsx)(t.em,{children:"ScoreFields"})," to sync the values instead. These fields are automatically populated by the Utility Window when you change the Number of Scores to Show."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"Start"}),", this program calls its own ",(0,n.jsx)(t.strong,{children:"Render"})," event once."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"Render"}),", the program calls ",(0,n.jsx)(t.strong,{children:"Render"})," on the ",(0,n.jsx)(t.em,{children:"scoreCam"}),", which will render its current view to a RenderTexture used all over the course to show the current score."]}),"\n",(0,n.jsxs)(t.p,{children:["When ",(0,n.jsx)(t.em,{children:"scoretoProcess"})," is changed on the Owner of this Object, we call ",(0,n.jsx)(t.strong,{children:"MakeRoom"})," and then ",(0,n.jsx)(t.strong,{children:"ProcessNextScore"}),". This works because every player in your instance will receive an update to ",(0,n.jsx)(t.em,{children:"timeElapsed"})," when someone finishes a run, and that program will update ",(0,n.jsx)(t.em,{children:"scoreToProcess"})," on this object if they are the owner."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"MakeRoom"}),", we check if our scoreFields are all full already, and if so we'll copy the values down iteratively to make room at the top."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"ProcessNextScore"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Pull apart the score into displayName and time again in order to format them nicely, and then set the ",(0,n.jsx)(t.em,{children:"targetVarName"})," value on the corresponding ",(0,n.jsx)(t.strong,{children:"ScoreField"})," to this. This target variable is synced, so we set it this way to update it for everyone."]}),"\n",(0,n.jsxs)(t.li,{children:["Compare the time of this score against the time of our High Score and update the ",(0,n.jsx)(t.strong,{children:"HighScoreField"})," if necessary."]}),"\n",(0,n.jsxs)(t.li,{children:["Set the value of ",(0,n.jsx)(t.em,{children:"scoreToProcess"})," to an empty string so its ready to process the next score that comes in."]}),"\n",(0,n.jsxs)(t.li,{children:["Send the ",(0,n.jsx)(t.strong,{children:"Render"})," event to everyone to update their score texture."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"scorefield",children:"ScoreField"}),"\n",(0,n.jsxs)(t.p,{children:["This program uses a simple and effective pattern - it has a public synced variable called ",(0,n.jsx)(t.em,{children:"log"}),". When log changes, it updates the text in the field to the new value. In this way, the values are synced and updated for everyone when the owner of the object updates it, which can be done easily from another program. In our case, we update this value from the ",(0,n.jsx)(t.strong,{children:"ScoreManager"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"highscorefield",children:"HighScoreField"}),"\n",(0,n.jsxs)(t.p,{children:["This program uses the same pattern as the score field above, but also has a synced ",(0,n.jsx)(t.em,{children:"score"}),' float that can be used to compare scores and update only if the new score is better. It also has a "prefix" which is a string injected before any changes. In this case, the string "High Score:" is prepended to the incoming string.']}),"\n",(0,n.jsx)(t.h1,{id:"powerups",children:"PowerUps"}),"\n",(0,n.jsxs)(t.p,{children:['It\'s fun to offer speed and jump boosts for players looking to maximize their scores, You can also use speed and jump penalties as part of obstacles and hazards to give your players some choice in strategy. PowerUps are all placed as children of the "PlayerModsManager" object when you create them with the Utility Window. They also have the ',(0,n.jsx)(t.em,{children:"PlayerModsManager"})," UdonBehaviour set on them automatically so they can apply their effects."]}),"\n",(0,n.jsxs)(t.p,{children:["They have a very simple program. It's called from an ",(0,n.jsx)(t.strong,{children:"OnPlayerDataEnter"})," program of course, and has a single ",(0,n.jsx)(t.strong,{children:"Trigger"})," event. Its variables are:"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"playerModsManager"}),": Automatically set when creating PowerUps through the Utility window. Used to actually apply the effects."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"speedChange"}),": Effect to apply to the Player's speed when triggered. 0 will skip, positive will increase speed, negative will decrease it."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"jumpChange"}),": Same as speedChange, but for Jump Impulse."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"effectDuration"}),": How long until the effect wears off."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"Trigger"}),", the program will set ",(0,n.jsx)(t.em,{children:"speedToProcess"})," on the ",(0,n.jsx)(t.strong,{children:"PlayerModsManager"})," if it's not 0, and it will set ",(0,n.jsx)(t.em,{children:"jumpToProcess"})," if it's not 0. In order to simplify the logic, we bundle the ",(0,n.jsx)(t.em,{children:"amount"})," and ",(0,n.jsx)(t.em,{children:"duration"})," values into a single Vector2, where the ",(0,n.jsx)(t.em,{children:"x"})," is amount and ",(0,n.jsx)(t.em,{children:"y"})," is duration."]}),"\n",(0,n.jsx)(t.h2,{id:"playermodsmanager",children:"PlayerModsManager"}),"\n",(0,n.jsx)(t.p,{children:'It\'s useful to have a central place to manage changes to a Player\'s abilities, especially when you consider that someone could run through a "Speed + 3" with a 2 second duration, and then a "Speed - 1" with a 3 second duration. In our program, speed mods cancel each other out, and jump mods cancel each other out. So in the example above, as soon as the Player triggered the "Speed- 1" PowerUp, they would reset to their default speed - 1, with a new 3 second timer running.'}),"\n",(0,n.jsxs)(t.p,{children:["The program works with a queue, like the ",(0,n.jsx)(t.strong,{children:"ScoreManager"}),". When ",(0,n.jsx)(t.em,{children:"speedToProcess"})," is changed, it will figure out the new speed to use, apply that to the VRCPlayerApi of the Local Player, and start a countdown based on the ",(0,n.jsx)(t.em,{children:"effectDuration"}),' of the PowerUp. The program displays the mod on the user\'s HUD and fades it out along with the timing so they Player can intuitively understand how much time is left. When the timer runs out, it resets the target property on the VRCPlayerApi to the default value, which is why we store and set those here instead of in the "VRCWorldSettings" program.']}),"\n",(0,n.jsx)(t.h2,{id:"destroyafterxseconds",children:"DestroyAfterXSeconds"}),"\n",(0,n.jsxs)(t.p,{children:["This simple program is useful for locally-instantiated objects, like the FX Prefabs created by ",(0,n.jsx)(t.strong,{children:"OnPlayerDataEnter"})," programs. It will ensure that the object destroys itself so you don't wind up with hundreds of old sound effects and particle systems sitting around."]}),"\n",(0,n.jsx)(t.h2,{id:"playclipfromarray",children:"PlayClipFromArray"}),"\n",(0,n.jsx)(t.p,{children:"This program is useful for introducing some variety in your sounds, for use on FX Prefabs for example. Instead of a single AudioClip, you can set a group of them on this program and it will randomly choose one when it is created and play that one. Could also be useful for a Footsteps program."}),"\n",(0,n.jsx)(t.h1,{id:"hazards",children:"Hazards"}),"\n",(0,n.jsx)(t.p,{children:"If you want to challenge your players, you can add a variety of hazards. We included a couple example programs, feel free to make your own!"}),"\n",(0,n.jsx)(t.h2,{id:"autorotate",children:"Autorotate"}),"\n",(0,n.jsxs)(t.p,{children:["This program simply rotates the Transform on which it lives. You can adjust the ",(0,n.jsx)(t.em,{children:"amount"})," for each axis, which will be multiplied by Time.deltaTime to ensure it rotates smoothly. An animator would have better performance, but this works when you're experimenting."]}),"\n",(0,n.jsx)(t.h2,{id:"spawnedhazard",children:"SpawnedHazard"}),"\n",(0,n.jsxs)(t.p,{children:["This hazard will reduce the speed of the Player who comes into contact with it. You can set ",(0,n.jsx)(t.em,{children:"speedChange"})," like you would on a PowerUp - the x is the amount to add to the Players' speed, and the y is the duration of the effect. To reduce a player's speed by 3 for 1 second, you would set ",(0,n.jsx)(t.em,{children:"speedChange"}),' to (-3,1). They find the "PlayerModsManager" GameObject and UdonBehaviour by name when they are created - not very performant but it works.']}),"\n",(0,n.jsx)(t.h2,{id:"hazardspawner",children:"HazardSpawner"}),"\n",(0,n.jsxs)(t.p,{children:["This program uses ",(0,n.jsx)(t.strong,{children:"SendCustomEventDelayedSeconds"})," to spawn hazards every ",(0,n.jsx)(t.em,{children:"delay"})," seconds. In our example project, we use slightly different delays to make a tricky hill of barrels for our players to dodge."]}),"\n",(0,n.jsx)(t.h2,{id:"fallingblock",children:"FallingBlock"}),"\n",(0,n.jsxs)(t.p,{children:["This program is the only one we include that interacts with a player and doesn't use ",(0,n.jsx)(t.strong,{children:"OnPlayerDataEnter"}),". This is because we want to know when a Player Enters ",(0,n.jsx)(t.em,{children:"and"})," when they Exit, which isn't accounted for in that program. When a player enters, we use ",(0,n.jsx)(t.strong,{children:"SendCustomEventDelayedSeconds"})," to run ",(0,n.jsx)(t.strong,{children:"CheckForDrop"})," after ",(0,n.jsx)(t.em,{children:"triggerTime"})," seconds."]}),"\n",(0,n.jsxs)(t.p,{children:["On ",(0,n.jsx)(t.strong,{children:"CheckForDrop"}),", if the player has not yet exited the collider, it will set its Rigidbody to non-kinematic, causing it to fall (and the player along with it). It will then call ",(0,n.jsx)(t.strong,{children:"Reset"})," after ",(0,n.jsx)(t.em,{children:"resetTime"})," seconds."]}),"\n",(0,n.jsx)(t.h1,{id:"misc",children:"Misc"}),"\n",(0,n.jsx)(t.h2,{id:"injection",children:"Injection"}),"\n",(0,n.jsxs)(t.p,{children:["This project has a system to inject references to certain components. It is described ",(0,n.jsx)(t.a,{href:"/worlds/examples/obstacle-course/build-from-custom-parts#advanced-stuff",children:"here"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);