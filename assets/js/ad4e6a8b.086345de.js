"use strict";(self.webpackChunkVRChat_Creator_Docs=self.webpackChunkVRChat_Creator_Docs||[]).push([[2548],{11450:(e,n,a)=>{a.d(n,{A:()=>r});const r=a.p+"assets/images/asyncgpureadback-mu8QGGS-fd0a8a726cd7cf21e0b444f4f3fddfa5.png"},28453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>o});var r=a(96540);const s={},t=r.createContext(s);function c(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(t.Provider,{value:n},e.children)}},56729:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"worlds/udon/vrc-graphics/asyncgpureadback","title":"AsyncGPUReadback","description":"AsyncGPUReadback in Unity is a feature that allows developers to copy data, such as a specific pixel\'s color, from textures on the GPU to code on the CPU. This function is similar to Texture2D.GetPixelsexcept it does not block tasks on the main thread as it runs asynchronously.","source":"@site/docs/worlds/udon/vrc-graphics/asyncgpureadback.md","sourceDirName":"worlds/udon/vrc-graphics","slug":"/worlds/udon/vrc-graphics/asyncgpureadback","permalink":"/creator-docs_ja/worlds/udon/vrc-graphics/asyncgpureadback","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1732237450000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"VRCGraphics","permalink":"/creator-docs_ja/worlds/udon/vrc-graphics/"},"next":{"title":"VRChat Shader Globals","permalink":"/creator-docs_ja/worlds/udon/vrc-graphics/vrchat-shader-globals"}}');var s=a(74848),t=a(28453),c=a(60575);const o={},i="AsyncGPUReadback",d={},l=[{value:"Differences between Unity AsyncGpuReadback and VRCAsyncGpuReadback",id:"differences-between-unity-asyncgpureadback-and-vrcasyncgpureadback",level:2},{value:"Using VRCAsyncGpuReadback",id:"using-vrcasyncgpureadback",level:2},{value:"Udon Node Graph Example",id:"udon-node-graph-example",level:2},{value:"UdonSharp Example",id:"udonsharp-example",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"asyncgpureadback",children:"AsyncGPUReadback"})}),"\n",(0,s.jsxs)(n.p,{children:["AsyncGPUReadback in Unity is a feature that allows developers to copy data, such as a specific pixel's color, from textures on the GPU to code on the CPU. This function is similar to ",(0,s.jsx)(n.code,{children:"Texture2D.GetPixels"}),"except it does not block tasks on the main thread as it runs asynchronously."]}),"\n",(0,s.jsx)(n.p,{children:"By performing the data transfer asynchronously, Unity ensures that the process does not negatively affect the application's frame rate and overall performance. AsyncGPUReadback helps developers avoid stalling the rendering pipeline, as the data transfer occurs in the background, parallel to the main thread."}),"\n",(0,s.jsx)(n.p,{children:"Common use cases for AsyncGPUReadback include generating CPU-side data based on the rendered output, such as creating a texture mipmap chain, implementing custom post-processing effects, or analyzing rendered frames for AI and computer vision purposes."}),"\n",(0,s.jsx)(n.h2,{id:"differences-between-unity-asyncgpureadback-and-vrcasyncgpureadback",children:"Differences between Unity AsyncGpuReadback and VRCAsyncGpuReadback"}),"\n",(0,s.jsx)(n.p,{children:"VRChat's implementation of AsyncGpuReadback employs a wrapper that calls the Unity functions. This wrapper uses a different interface. The differences are as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rather than calling AsyncGpuReadback, you need to use VRCAsyncGpuReadback."}),"\n",(0,s.jsxs)(n.li,{children:["Rather than providing ",(0,s.jsx)(n.code,{children:"Action<AsyncGPUReadbackRequest> callback"}),", you provide an UdonBehaviour, and then that UdonBehaviour will receive ",(0,s.jsx)(n.code,{children:"OnAsyncGpuReadbackComplete"})," when the readback is complete."]}),"\n",(0,s.jsxs)(n.li,{children:["Rather than using ",(0,s.jsx)(n.code,{children:"GetData"})," on the completed readback, you need to use ",(0,s.jsx)(n.code,{children:"TryGetData"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"See Unity's documentation on this feature for other shared details:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(c.A,{versionKey:"minor",url:"https://docs.unity3d.com/<VERSION>/Documentation/ScriptReference/Rendering.AsyncGPUReadback.Request.html",children:"Making a readback request"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(c.A,{versionKey:"minor",url:"https://docs.unity3d.com/<VERSION>/Documentation/ScriptReference/Rendering.AsyncGPUReadbackRequest.html",children:"Getting data from a readback"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"using-vrcasyncgpureadback",children:"Using VRCAsyncGpuReadback"}),"\n",(0,s.jsx)(n.p,{children:"When using VRCAsyncGpuReadback, there are 4 main steps that you need to follow:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Set up an array of data to be used."}),"\n",(0,s.jsx)(n.li,{children:"Make the AsyncGpuReadback request"}),"\n",(0,s.jsx)(n.li,{children:"Receive the message when the request is complete"}),"\n",(0,s.jsx)(n.li,{children:"Get the data out of the request"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"udon-node-graph-example",children:"Udon Node Graph Example"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"asyncgpureadback-mu8QGGS.png",src:a(11450).A+"",width:"1432",height:"1142"})}),"\n",(0,s.jsx)(n.h2,{id:"udonsharp-example",children:"UdonSharp Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'\r\nusing UdonSharp;\r\nusing UnityEngine;\r\nusing VRC.SDK3.Rendering;\r\nusing VRC.Udon.Common.Interfaces;\r\n\u200b\r\npublic class AGPURB : UdonSharpBehaviour\r\n{\r\n    public Texture texture;\r\n\u200b\r\n    void Start()\r\n    {\r\n        VRCAsyncGPUReadback.Request(texture, 0, (IUdonEventReceiver)this);\r\n    }\r\n\u200b\r\n    public void OnAsyncGpuReadbackComplete(VRCAsyncGPUReadbackRequest request)\r\n    {\r\n        if (request.hasError)\r\n        {\r\n            Debug.LogError("GPU readback error!");\r\n            return;\r\n        }\r\n        else\r\n        {\r\n            var px = new Color32[texture.width * texture.height];\r\n            Debug.Log("GPU readback success: " + request.TryGetData(px));\r\n            Debug.Log("GPU readback data: " + px[0]);\r\n        }\r\n    }\r\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},60575:(e,n,a)=>{a.d(n,{A:()=>t});var r=a(78429),s=a(74848);const t=e=>{let{versionKey:n,url:a,children:t}=e;const c=r.n[n]||r.n.defaultVersion,o=a.replace("<VERSION>",c);return(0,s.jsx)("a",{href:o,target:"_blank",children:t})}},78429:(e,n,a)=>{a.d(n,{n:()=>r});const r={major:"2022",minor:"2022.3",patch:"2022.3.22",defaultVersion:"2022.3.22f1"}}}]);