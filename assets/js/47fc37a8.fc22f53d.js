"use strict";(self.webpackChunkVRChat_Creator_Docs=self.webpackChunkVRChat_Creator_Docs||[]).push([[936],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(96540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}},60575:(e,t,n)=>{n.d(t,{A:()=>r});var i=n(78429),s=n(74848);const r=e=>{let{versionKey:t,url:n,children:r}=e;const o=i.n[t]||i.n.defaultVersion,a=n.replace("<VERSION>",o);return(0,s.jsx)("a",{href:a,target:"_blank",children:r})}},75810:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"worlds/udon/networking/network-components","title":"Network Components","description":"This doc covers Networking Components, Properties and Events you can use in your Udon Programs.","source":"@site/docs/worlds/udon/networking/network-components.md","sourceDirName":"worlds/udon/networking","slug":"/worlds/udon/networking/network-components","permalink":"/creator-docs_ja/worlds/udon/networking/network-components","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1732237450000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Networking","permalink":"/creator-docs_ja/worlds/udon/networking/"},"next":{"title":"Networking Specs & Tricks","permalink":"/creator-docs_ja/worlds/udon/networking/network-details"}}');var s=n(74848),r=n(28453),o=n(60575);const a={},l="Network Components",d={},c=[{value:"Networking Properties",id:"networking-properties",level:2},{value:"Simulation time",id:"simulation-time",level:3},{value:"Networking Events",id:"networking-events",level:2},{value:"OnPreSerialization",id:"onpreserialization",level:3},{value:"OnDeserialization",id:"ondeserialization",level:3},{value:"OnDeserialization(DeserializationResult)",id:"ondeserializationdeserializationresult",level:3},{value:"DeserializationResult",id:"deserializationresult",level:4},{value:"OnPostSerialization",id:"onpostserialization",level:3},{value:"OnSpawn",id:"onspawn",level:3},{value:"OnOwnershipRequest",id:"onownershiprequest",level:3},{value:"OnOwnershipTransferred",id:"onownershiptransferred",level:3},{value:"OnMasterTransferred",id:"onmastertransferred",level:3},{value:"OnVariableChanged",id:"onvariablechanged",level:3},{value:"VRC Object Sync",id:"vrc-object-sync",level:2},{value:"FlagDiscontinuity",id:"flagdiscontinuity",level:3},{value:"Set/Get Gravity",id:"setget-gravity",level:3},{value:"Set/Get Kinematic",id:"setget-kinematic",level:3},{value:"Respawn",id:"respawn",level:3},{value:"VRC Object Pool",id:"vrc-object-pool",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"network-components",children:"Network Components"})}),"\n",(0,s.jsx)(t.p,{children:"This doc covers Networking Components, Properties and Events you can use in your Udon Programs."}),"\n",(0,s.jsx)(t.h2,{id:"networking-properties",children:"Networking Properties"}),"\n",(0,s.jsxs)(t.p,{children:["Special properties you can ",(0,s.jsx)(t.em,{children:"get"})," from Networking:"]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Property name"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"LocalPlayer"}),(0,s.jsxs)(t.td,{children:["Returns the ",(0,s.jsx)(t.a,{href:"/worlds/udon/players",children:"VRC Player API"})," object of the local player."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"IsInstanceOwner"}),(0,s.jsxs)(t.td,{children:["Returns ",(0,s.jsx)(t.code,{children:"true"})," for the instance creator in Invite, Invite+, Friends, and Friends+ instances.",(0,s.jsx)("br",{}),"Always returns ",(0,s.jsx)(t.code,{children:"false"}),' in Group instances, Public instances, and the SDK\'s "Build & Test" mode.']})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"InstanceOwner"}),(0,s.jsxs)(t.td,{children:["Returns the ",(0,s.jsx)(t.a,{href:"/worlds/udon/players",children:"VRC Player API"})," object of the player who owns the instance. If the owner is currently not in the instance, this returns ",(0,s.jsx)(t.code,{children:"null"})," instead. If the owner returns, it returns the instance owner again.",(0,s.jsx)("br",{}),"The instance owner has special moderation permissions. Instance ownership never changes."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"IsMaster"}),(0,s.jsxs)(t.td,{children:["Returns ",(0,s.jsx)(t.code,{children:"true"})," if the local player is the ",(0,s.jsx)(t.a,{href:"/worlds/udon/networking/#the-instance-master",children:"instance master"}),". The master is the default owner for networked game objects.",(0,s.jsx)("br",{}),"You should not use this for security or gating access to your world. Use ",(0,s.jsx)(t.code,{children:"IsInstanceOwner"})," or implement a moderation system instead."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Master"}),(0,s.jsxs)(t.td,{children:["Returns the ",(0,s.jsx)(t.a,{href:"/worlds/udon/players",children:"VRC Player API"})," object of the player who is the current instance master. Is always valid."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"IsNetworkSettled"}),(0,s.jsxs)(t.td,{children:["Returns ",(0,s.jsx)(t.code,{children:"true"})," if all the data in the instance has been deserialized, applied, and is ready for use."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"IsClogged"}),(0,s.jsxs)(t.td,{children:["Returns ",(0,s.jsx)(t.code,{children:"true"})," if there is too much data trying to get out. You can use this to wait until the network is unclogged or to adjust your logic."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"SimulationTime"}),(0,s.jsx)(t.td,{children:"Returns the current simulation time of a player or object with networking components. See below for more details."})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"simulation-time",children:"Simulation time"}),"\n",(0,s.jsxs)(t.p,{children:["Simulation time is a timestamp that refers to how far back in time an object is simulated. This value is used internally for ",(0,s.jsx)(t.a,{href:"/worlds/udon/networking/network-components#vrc-object-sync",children:(0,s.jsx)(t.code,{children:"VRCObjectSync"})})," and ",(0,s.jsx)(t.a,{href:"/worlds/udon/players#simulationtime",children:"players"}),", but can be used in Udon scripts as well. For example, if your ",(0,s.jsx)(t.code,{children:"Time.realtimeSinceStartup"})," is 45 and the SimulationTime of an object is 44.5, then VRChat believes 500ms of delay is necessary to smoothly replicate the object at that moment. You can use that number to learn some information about what ",(0,s.jsx)(t.code,{children:"VRCObjectSync"})," is doing, or to create your own system similar to ",(0,s.jsx)(t.code,{children:"VRCObjectSync"}),". For example, if you do ",(0,s.jsx)(t.code,{children:"Time.realTimeSinceStartup - SimulationTime(player)"})," then that will tell you exactly how much latency that player has at that moment."]}),"\n",(0,s.jsx)(t.p,{children:"Simulation time is frequently adjusted depending on network conditions, including many factors such as latency, reliability, and frequency of the packets being received. The goal of this adjustment is to be as close to real-time as possible to reduce latency, but to leave enough room to prevent hitching. There are a variety of factors that can cause hitching, but one example can be running out of received packets from the owner."}),"\n",(0,s.jsx)(t.h2,{id:"networking-events",children:"Networking Events"}),"\n",(0,s.jsx)(t.p,{children:"These are the events available as part of the Networking system to control how your data is synced."}),"\n",(0,s.jsx)(t.h3,{id:"onpreserialization",children:"OnPreSerialization"}),"\n",(0,s.jsx)(t.p,{children:"This event triggers just before serialized data will be sent out, it's a good place to set synced variables that you want to be updated for other players."}),"\n",(0,s.jsx)(t.h3,{id:"ondeserialization",children:"OnDeserialization"}),"\n",(0,s.jsxs)(t.p,{children:["This event triggers when sync data has been transformed from bytes back into usable variables. It does not tell you ",(0,s.jsx)(t.em,{children:"which"})," data has been updated, but serves as a jumping-off point to either update everything that watches synced variables, or a place to check new data against old data and make specific updates."]}),"\n",(0,s.jsx)(t.h3,{id:"ondeserializationdeserializationresult",children:"OnDeserialization(DeserializationResult)"}),"\n",(0,s.jsx)(t.p,{children:"Same as OnDeserialization, but with additional information about the time at which the request was sent and received."}),"\n",(0,s.jsx)(t.h4,{id:"deserializationresult",children:"DeserializationResult"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"DeserializationResult"})," contains three properties:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"sendTime"}),": The time in seconds at which this message was sent."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"receiveTime"}),": The time in seconds at which this message was received."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"isFromStorage"}),": If true, then the included data was restored from storage rather than received from other realtime clients."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Both ",(0,s.jsx)(t.code,{children:"sendTime"})," and ",(0,s.jsx)(t.code,{children:"receiveTime"})," measure based on the time in seconds since VRChat has started, from your perspective (see ",(0,s.jsx)(o.A,{versionKey:"minor",url:"https://docs.unity3d.com/<VERSION>/Documentation/ScriptReference/Time-realtimeSinceStartup.html",children:"Time.realtimeSinceStartup"}),"). This means that if you want to know how many seconds ago a certain Deserialization was sent, you can calculate it with ",(0,s.jsx)(t.code,{children:"Time.realtimeSinceStartup - sendTime"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Note that every user's ",(0,s.jsx)(t.code,{children:"Time.realtimeSinceStartup"})," is different, so one player's ",(0,s.jsx)(t.code,{children:"sendTime"})," is going to be different from another player's ",(0,s.jsx)(t.code,{children:"sendTime"}),". As a result, if you want to sync a specific ",(0,s.jsx)(t.code,{children:"sendTime"})," to other players, you will need to calculate its offset by subtracting your ",(0,s.jsx)(t.code,{children:"Time.realtimeSinceStartup"}),". Then, when the other players receive that offset, they can add back their own ",(0,s.jsx)(t.code,{children:"Time.realtimeSinceStartup"})," to the offset in order to determine the absolute time relative to their own clock."]}),"\n",(0,s.jsx)(t.p,{children:"SendTime can be a negative number if the message was sent by someone else before you ever launched VRChat."}),"\n",(0,s.jsx)(t.h3,{id:"onpostserialization",children:"OnPostSerialization"}),"\n",(0,s.jsxs)(t.p,{children:["This event triggers just after an attempt was made to send serialized data. It returns a ",(0,s.jsx)(t.strong,{children:"SerializationResult"})," struct with a 'success' bool and 'byteCount' int with the number of bytes sent."]}),"\n",(0,s.jsx)(t.h3,{id:"onspawn",children:"OnSpawn"}),"\n",(0,s.jsx)(t.p,{children:"This event is deprecated - use the typical OnEnabled event if you want to do something when an object is 'Spawned' from the pool."}),"\n",(0,s.jsx)(t.h3,{id:"onownershiprequest",children:"OnOwnershipRequest"}),"\n",(0,s.jsx)(t.p,{children:'This event is triggered when someone has requested to take ownership. It includes the PlayerObjects for the Requester and the Requested Owner. To approve or deny the change, set a boolean value into a "Set Return Value" node. This logic runs locally on both the requester and the owner, so be aware that disagreements in logic between the two will cause a desync. This is most likely to be expressed by the ownership transfer being unexpectedly rejected by the owner.'}),"\n",(0,s.jsx)(t.h3,{id:"onownershiptransferred",children:"OnOwnershipTransferred"}),"\n",(0,s.jsx)(t.p,{children:"This event is triggered for everyone in the instance when an objects ownership is changed, and includes the PlayerObject for the new owner."}),"\n",(0,s.jsx)(t.h3,{id:"onmastertransferred",children:"OnMasterTransferred"}),"\n",(0,s.jsxs)(t.p,{children:["This event is triggered for everyone in the instance when the instance master changes because the previous instance master has left the instance.\r\nIt includes one parameter, ",(0,s.jsx)(t.code,{children:"newMaster,"})," which is the ",(0,s.jsx)(t.a,{href:"/worlds/udon/players",children:"VRC Player API"})," object of the player that has become master. This parameter is always valid.\r\nFor the first user joining a new instance, this event will trigger after ",(0,s.jsx)(t.code,{children:"OnPlayerJoined"}),' to indicate that the master state was transferred from "nobody".']}),"\n",(0,s.jsx)(t.h3,{id:"onvariablechanged",children:"OnVariableChanged"}),"\n",(0,s.jsx)(t.p,{children:"This is a special type of event that you can create for any variable. In Udon Graph, you create it by dragging and dropping a variable into the graph while holding alt. This event detects when the variable changes, which can include when you receive synced variables from other players."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"changing the contents of an array does not trigger a change, because the array itself is still the same."}),"\n",(0,s.jsx)(t.li,{children:"OnVariableChanged triggers immediately when the variable itself is written to, unlike OnDeserialization which triggers after it has finished writing all the synced variables. This means that if you use OnVariableChanged from one synced variable and try to get the contents of a different synced variable, it is not guaranteed that it has been updated with the latest synced data yet."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"vrc-object-sync",children:"VRC Object Sync"}),"\n",(0,s.jsx)(t.p,{children:"This component will automatically sync the Transform (position, rotation scale) and Rigidbody (physics) of the object you put it on. It has a few special methods and properties you can access:"}),"\n",(0,s.jsx)(t.h3,{id:"flagdiscontinuity",children:"FlagDiscontinuity"}),"\n",(0,s.jsx)(t.p,{children:"Trigger this when you want to teleport the object - the changes you make this frame will be applied without smoothing."}),"\n",(0,s.jsx)(t.h3,{id:"setget-gravity",children:"Set/Get Gravity"}),"\n",(0,s.jsxs)(t.p,{children:["When gravity is on, this rigidbody is affected by gravity and will fall to the ground. Normally, gravity is a property of the rigidbody. However, when you have VRCObjectSync, this property must be controlled by the VRCObjectSync component instead. You can use these functions to do that. This effectively behaves like a synced variable, so ",(0,s.jsx)(t.strong,{children:"only the owner can set gravity."})]}),"\n",(0,s.jsx)(t.h3,{id:"setget-kinematic",children:"Set/Get Kinematic"}),"\n",(0,s.jsxs)(t.p,{children:["When kinematic is on, this rigidbody ignores forces, collisions and joints. Normally, kinematic is a property of the rigidbody.  However, when you have VRCObjectSync, this property must be controlled by the VRCObjectSync component instead. You can use these functions to do that. This effectively behaves like a synced variable, so ",(0,s.jsx)(t.strong,{children:"only the owner can set kinematic."})]}),"\n",(0,s.jsx)(t.h3,{id:"respawn",children:"Respawn"}),"\n",(0,s.jsxs)(t.p,{children:["Teleports this object back to its starting Position and Rotation, and removes its Velocities.\r\nSpecifically, it sets ",(0,s.jsx)(t.strong,{children:"DiscontinuityHint"})," to true to make the following changes instant instead of smooth. Then it:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"sets transform.position to initial position"}),"\n",(0,s.jsx)(t.li,{children:"sets transform.rotation to initial rotation"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If the object has a rigidbody:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"sets the rigidbody.velocity to Vector3.zero"}),"\n",(0,s.jsx)(t.li,{children:"sets the rigidbody.angularVelocity Vector3.zero"}),"\n",(0,s.jsx)(t.li,{children:"sets the rigidbody.position to initial position"}),"\n",(0,s.jsx)(t.li,{children:"sets the rigidbody.rotation to initial rotation"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"vrc-object-pool",children:"VRC Object Pool"}),"\n",(0,s.jsx)(t.p,{children:"VRC Object Pool provides a lightweight method of managing an array of game objects. The pool will manage and synchronize the active state of each object it holds."}),"\n",(0,s.jsxs)(t.p,{children:["To make an object active, the Owner of the pool triggers the ",(0,s.jsx)(t.strong,{children:"TryToSpawn"})," node, which will return the object that was made active, or a null object if none are available. Objects may be returned to the pool by the pool's owner, and automatically disabled, via the ",(0,s.jsx)(t.strong,{children:"Return"})," node."]}),"\n",(0,s.jsx)(t.p,{children:"Late joiners will have the objects automatically made active or inactive where appropriate."})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},78429:(e,t,n)=>{n.d(t,{n:()=>i});const i={major:"2022",minor:"2022.3",patch:"2022.3.22",defaultVersion:"2022.3.22f1"}}}]);