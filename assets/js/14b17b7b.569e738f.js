"use strict";(self.webpackChunkVRChat_Creator_Docs=self.webpackChunkVRChat_Creator_Docs||[]).push([[2387],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>o});var i=s(96540);const t={},r=i.createContext(t);function d(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(r.Provider,{value:n},e.children)}},69307:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"worlds/udon/vm-and-assembly/index","title":"The Udon VM and Udon Assembly","description":"This page was written by a member of the VRChat community. Thank you for your contribution!","source":"@site/docs/worlds/udon/vm-and-assembly/index.md","sourceDirName":"worlds/udon/vm-and-assembly","slug":"/worlds/udon/vm-and-assembly/","permalink":"/creator-docs_ja/worlds/udon/vm-and-assembly/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1711147628000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Video Player Allowlist","permalink":"/creator-docs_ja/worlds/udon/video-players/www-whitelist"},"next":{"title":"VRCGraphics","permalink":"/creator-docs_ja/worlds/udon/vrc-graphics/"}}');var t=s(74848),r=s(28453);const d={},o="The Udon VM and Udon Assembly",a={},l=[{value:"Overview of the Udon VM",id:"overview-of-the-udon-vm",level:2},{value:"Udon Types",id:"udon-types",level:2},{value:"Udon Assembly",id:"udon-assembly",level:2},{value:"The Data Section",id:"the-data-section",level:3},{value:"The Code Section",id:"the-code-section",level:3},{value:"Udon Opcodes",id:"udon-opcodes",level:2},{value:"<code>NOP</code>",id:"nop",level:3},{value:"<code>PUSH, parameter</code>",id:"push-parameter",level:3},{value:"<code>POP</code>",id:"pop",level:3},{value:"<code>JUMP_IF_FALSE, parameter</code>",id:"jump_if_false-parameter",level:3},{value:"<code>JUMP, parameter</code>",id:"jump-parameter",level:3},{value:"<code>EXTERN, parameter</code>",id:"extern-parameter",level:3},{value:"<code>ANNOTATION, parameter</code>",id:"annotation-parameter",level:3},{value:"<code>JUMP_INDIRECT, parameter</code>",id:"jump_indirect-parameter",level:3},{value:"<code>COPY</code>",id:"copy",level:3},{value:"Externs Reference",id:"externs-reference",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"the-udon-vm-and-udon-assembly",children:"The Udon VM and Udon Assembly"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:'This page was written by a member of the VRChat community. Thank you for your contribution!\r\nThe VRChat team can\'t guarantee the validity of the information on this page. If you would like to suggest changes, go to the bottom of this page and click "Edit this page."'})}),"\n",(0,t.jsx)(n.h2,{id:"overview-of-the-udon-vm",children:"Overview of the Udon VM"}),"\n",(0,t.jsx)(n.p,{children:"The Udon VM is a bytecode interpreter designed to run compiled Udon Graph programs."}),"\n",(0,t.jsx)(n.p,{children:"As such, it's important to keep in mind what it has and doesn't have:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The Udon VM is expected to be running inside a .NET environment. While reflection is not used to access functions, the Udon VM is 'styled' like it is."}),"\n",(0,t.jsxs)(n.li,{children:["It doesn't directly implement call/return or subroutines (though ",(0,t.jsx)(n.code,{children:"JUMP_INDIRECT"})," exists and can be used for the purpose)."]}),"\n",(0,t.jsxs)(n.li,{children:["It has flow control, via ",(0,t.jsx)(n.code,{children:"JUMP"}),", ",(0,t.jsx)(n.code,{children:"JUMP_INDIRECT"}),", and ",(0,t.jsx)(n.code,{children:"JUMP_IF_FALSE"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"It can call functions from C# (where allowed)."}),"\n",(0,t.jsx)(n.li,{children:"It doesn't have local variables; only fields on the object."}),"\n",(0,t.jsx)(n.li,{children:'It has an integer stack, but this integer stack should be treated as essentially "extra parameters" for opcodes in most cases. It is possible to use it as part of a call/return mechanism, but remember that there are no local variables, so recursive functions must be implemented very carefully.'}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsx)(n.p,{children:"You can export Udon Assembly from Udon Graph and UdonSharp programs."}),(0,t.jsx)(n.p,{children:"This can help in getting an idea of how the code you write is compiled, and help you find extern names!"})]}),"\n",(0,t.jsx)(n.h2,{id:"udon-types",children:"Udon Types"}),"\n",(0,t.jsx)(n.p,{children:'"Udon Types" are how Udon refers to C# types.'}),"\n",(0,t.jsxs)(n.p,{children:["The easiest way to understand these type names is to start with the corresponding .NET name, such as ",(0,t.jsx)(n.code,{children:"System.Int32[]"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"There are various rules in the construction of Udon Types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["All ",(0,t.jsx)(n.code,{children:"."}),"s and ",(0,t.jsx)(n.code,{children:"+"}),"s are removed, i.e. ",(0,t.jsx)(n.code,{children:"VRC.SDKBase.VRCPlayerApi+TrackingData"})," becomes ",(0,t.jsx)(n.code,{children:"VRCSDKBaseVRCPlayerApiTrackingData"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The type may have ",(0,t.jsx)(n.code,{children:"Array"})," appended, representing ",(0,t.jsx)(n.code,{children:"[]"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["As such, the example above is ",(0,t.jsx)(n.code,{children:"SystemInt32Array"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"udon-assembly",children:"Udon Assembly"}),"\n",(0,t.jsx)(n.p,{children:"Udon Assembly programs are made up of two sections: The data section, and the code section."}),"\n",(0,t.jsx)(n.p,{children:"These sections are marked with start/end directives, as so:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:".data_start\r\n    # Data goes here!\r\n.data_end\r\n.code_start\r\n    # Code goes here, instead!\r\n.code_end\n"})}),"\n",(0,t.jsx)(n.h3,{id:"the-data-section",children:"The Data Section"}),"\n",(0,t.jsx)(n.p,{children:"The data section marks the behaviour's variables, and which are exported (public)."}),"\n",(0,t.jsx)(n.p,{children:'Data in these sections is stored in the "Udon Heap", which, despite the name, is in fact a flat array of values with their types. A "heap index" is an index in this array.'}),"\n",(0,t.jsx)(n.p,{children:"An example of defining a variable in Udon Assembly:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'message: %SystemString, "Hello, world!"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here, the variable's symbol is ",(0,t.jsx)(n.code,{children:"message"}),", the type is ",(0,t.jsx)(n.code,{children:"SystemString"}),", and the contents are ",(0,t.jsx)(n.code,{children:'"Hello, world!"'}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that the type may be better described as the ",(0,t.jsx)(n.em,{children:"initial"})," type, as variables can change type at runtime (but probably shouldn't if public)."]}),"\n",(0,t.jsxs)(n.p,{children:["Values can be ",(0,t.jsx)(n.code,{children:"null"}),", ",(0,t.jsx)(n.code,{children:"this"}),", ",(0,t.jsx)(n.code,{children:"true"}),", ",(0,t.jsx)(n.code,{children:"false"}),", strings, character constants, integers, unsigned integers (integers ending with ",(0,t.jsx)(n.code,{children:"u"}),"), and floats, though the assembler is strict about which of these can be specified when."]}),"\n",(0,t.jsx)(n.p,{children:"In particular:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SystemSingle"})," and ",(0,t.jsx)(n.code,{children:"SystemDouble"})," must be numbers or ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SystemInt32"})," and ",(0,t.jsx)(n.code,{children:"SystemUInt32"})," must be integers of either kind or ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SystemString"})," must be a string literal or ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["All other types, including ",(0,t.jsx)(n.code,{children:"SystemObject"}),", can only be ",(0,t.jsx)(n.code,{children:"this"})," or ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"this"}),' does not have its "traditional" meaning per-se. Depending on the type of the variable, it can be:']}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"GameObject"}),": The ",(0,t.jsx)(n.code,{children:"GameObject"})," of the ",(0,t.jsx)(n.code,{children:"UdonBehaviour"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Transform"}),": ",(0,t.jsx)(n.code,{children:"GameObject.transform"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"UdonBehaviour"}),", ",(0,t.jsx)(n.code,{children:"IUdonBehaviour"}),", or ",(0,t.jsx)(n.code,{children:"Object"}),": The ",(0,t.jsx)(n.code,{children:"UdonBehaviour"})," itself."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If it is none of these, an error occurs."}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsxs)(n.p,{children:["It is not presently possible to specify a non-null value for ",(0,t.jsx)(n.code,{children:"SystemType"})," in Udon Assembly, but it is possible in Udon Graph and UdonSharp. Similar issues exist for ",(0,t.jsx)(n.code,{children:"SystemInt64"}),", ",(0,t.jsx)(n.code,{children:"SystemUInt64"}),", ",(0,t.jsx)(n.code,{children:"SystemSByte"}),", ",(0,t.jsx)(n.code,{children:"SystemByte"}),", ",(0,t.jsx)(n.code,{children:"SystemInt16"}),", ",(0,t.jsx)(n.code,{children:"SystemUInt16"}),", and ",(0,t.jsx)(n.code,{children:"SystemBoolean"})," (yes, it is impossible to actually ",(0,t.jsx)(n.em,{children:"successfully"})," specify ",(0,t.jsx)(n.code,{children:"true"})," or ",(0,t.jsx)(n.code,{children:"false"}),")."]}),(0,t.jsx)(n.p,{children:"These are Udon Assembly limitations. They can only be circumvented by not using Udon Assembly."}),(0,t.jsx)(n.p,{children:"Floating-point numbers are always read as floats, even if the intended type is a double."})]}),"\n",(0,t.jsxs)(n.p,{children:["These variables can also be marked as public, using, i.e. ",(0,t.jsx)(n.code,{children:".export message"}),", and can be marked with sync metadata, i.e. ",(0,t.jsx)(n.code,{children:".sync message, none"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Marking a variable with sync metadata is equivalent to the ",(0,t.jsx)(n.code,{children:"synced"})," checkbox; see ",(0,t.jsx)(n.a,{href:"../networking#variables",children:"Networking"})," for details."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"none"})," here is the interpolation mode. The interpolation modes are ",(0,t.jsx)(n.code,{children:"none"}),", ",(0,t.jsx)(n.code,{children:"linear"}),", and ",(0,t.jsx)(n.code,{children:"smooth"}),", though not all interpolation modes are valid for all types."]}),"\n",(0,t.jsx)(n.h3,{id:"the-code-section",children:"The Code Section"}),"\n",(0,t.jsx)(n.p,{children:"The code section is a list of opcodes with labels and possible exports."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'.export _start\r\n_start:\r\n\tPUSH, message\r\n\tEXTERN, "UnityEngineDebug.__Log__SystemObject__SystemVoid"\r\n\tJUMP, 0xFFFFFFFC\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:".export _start"})," (an example; replace ",(0,t.jsx)(n.code,{children:"_start"})," with whatever symbol you're exporting) is used to export code symbols for event handlers."]}),"\n",(0,t.jsxs)(n.p,{children:["Standard events start with ",(0,t.jsx)(n.code,{children:"_"})," and have their parameters passed in variables, not public, which you are expected to create; this is a long list, and best explored via Udon Graph."]}),"\n",(0,t.jsxs)(n.p,{children:["However, importantly, the first two events that run are ",(0,t.jsx)(n.code,{children:"_onEnable"})," and ",(0,t.jsx)(n.code,{children:"_start"}),", in that order. There is no gap between them in this initial run, and these will always run before any other event; if something attempts to bypass that, the invocation will be ignored. See ",(0,t.jsx)(n.a,{href:"../event-execution-order",children:"Event Execution Order"})," for more details."]}),"\n",(0,t.jsxs)(n.p,{children:["Custom events never take parameters (outside of whatever mechanism you define), and don't start with ",(0,t.jsx)(n.code,{children:"_"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The actual opcodes are reasonably simple. There is the opcode name, and then for some opcodes, a parameter. This parameter can be an integer, a symbol (integer value of that symbol, i.e. heap index or code address), or a string. When it is a string, the assembler will create a hidden, unnamed variable for that string, and the actual value will be the heap index."}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["For some reason, defining two code symbols that point to the same position is not allowed, causing an ",(0,t.jsx)(n.code,{children:"Address aliasing detected"})," error."]})}),"\n",(0,t.jsx)(n.h2,{id:"udon-opcodes",children:"Udon Opcodes"}),"\n",(0,t.jsx)(n.h3,{id:"nop",children:(0,t.jsx)(n.code,{children:"NOP"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 0"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 0"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This opcode does nothing. There is generally no reason to use this, unless you get the ",(0,t.jsx)(n.code,{children:"Address aliasing detected:"})," error."]}),"\n",(0,t.jsx)(n.h3,{id:"push-parameter",children:(0,t.jsx)(n.code,{children:"PUSH, parameter"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 1"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 1"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This opcode pushes an integer to the top of the stack."}),"\n",(0,t.jsx)(n.p,{children:"Udon Assembly may give the impression that a value is being pushed; this is not the case."}),"\n",(0,t.jsx)(n.p,{children:"In these cases, it is the heap address that is being pushed."}),"\n",(0,t.jsxs)(n.p,{children:["Unless you are very dedicated to size-optimizing your Udon programs (even at the expense of runtime speed in some cases), or trying to obfuscate, there is never any reason to use this in a conditional fashion. Simply push everything immediately before ",(0,t.jsx)(n.code,{children:"EXTERN"}),", ",(0,t.jsx)(n.code,{children:"COPY"})," or ",(0,t.jsx)(n.code,{children:"JUMP_IF_FALSE"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"pop",children:(0,t.jsx)(n.code,{children:"POP"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 2"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 0"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This opcode removes the top integer from the stack, with no further effects."}),"\n",(0,t.jsx)(n.h3,{id:"jump_if_false-parameter",children:(0,t.jsx)(n.code,{children:"JUMP_IF_FALSE, parameter"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 4"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 1"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Pops a heap index from the stack and reads a ",(0,t.jsx)(n.code,{children:"SystemBoolean"})," from it."]}),"\n",(0,t.jsxs)(n.p,{children:["If this value is ",(0,t.jsx)(n.code,{children:"false"}),", jumps to the parameter as a bytecode position. Otherwise, continues to the next instruction."]}),"\n",(0,t.jsx)(n.h3,{id:"jump-parameter",children:(0,t.jsx)(n.code,{children:"JUMP, parameter"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 5"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 1"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Jumps to the bytecode position given by the parameter."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"JUMP, 0xFFFFFFFC"})," is also used to end execution (i.e. return from Udon code)."]}),"\n",(0,t.jsx)(n.h3,{id:"extern-parameter",children:(0,t.jsx)(n.code,{children:"EXTERN, parameter"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 6"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 1"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This opcode is how Udon performs any useful operation whatsoever."}),"\n",(0,t.jsxs)(n.p,{children:["The first thing to note is that the parameter is a heap index, initially containing the extern name (as a string), ",(0,t.jsx)(n.em,{children:"but this is also written to."})]}),"\n",(0,t.jsx)(n.p,{children:"As an optimization, Udon caches information about the extern after it is first run in the given heap index. These values are still heap values and can be copied."}),"\n",(0,t.jsxs)(n.p,{children:["The parameters to the extern are given in ",(0,t.jsx)(n.code,{children:"PUSH"})," order; that is, the first value pushed is the first argument."]}),"\n",(0,t.jsxs)(n.p,{children:["These heap values are read for normal (i.e. ",(0,t.jsx)(n.code,{children:"in"}),") arguments, read and written for ",(0,t.jsx)(n.code,{children:"ref"})," arguments, and written for ",(0,t.jsx)(n.code,{children:"out"})," arguments."]}),"\n",(0,t.jsxs)(n.p,{children:["If the extern is not static (i.e. if it has a ",(0,t.jsx)(n.code,{children:"this"})," argument), the ",(0,t.jsx)(n.code,{children:"this"})," argument is added at the start. If there is a return value (i.e. the return type is not ",(0,t.jsx)(n.code,{children:"SystemVoid"}),"), it is treated like an ",(0,t.jsx)(n.code,{children:"out"})," argument at the end."]}),"\n",(0,t.jsx)(n.h3,{id:"annotation-parameter",children:(0,t.jsx)(n.code,{children:"ANNOTATION, parameter"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 7"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 1"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'This is effectively a "long NOP". The parameter is ignored.'}),"\n",(0,t.jsx)(n.h3,{id:"jump_indirect-parameter",children:(0,t.jsx)(n.code,{children:"JUMP_INDIRECT, parameter"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 8"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 1"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Gets a heap index from the parameter and reads a ",(0,t.jsx)(n.code,{children:"SystemUInt32"})," from it."]}),"\n",(0,t.jsx)(n.p,{children:"Interprets this as a bytecode position and jumps to it."}),"\n",(0,t.jsx)(n.h3,{id:"copy",children:(0,t.jsx)(n.code,{children:"COPY"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Opcode: 9"}),"\n",(0,t.jsx)(n.li,{children:"Parameters: 0"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Pops two heap indexes. The value from the second heap index popped (aka the first heap index pushed) is copied to the first heap index popped (aka the second heap index pushed)."}),"\n",(0,t.jsx)(n.h2,{id:"externs-reference",children:"Externs Reference"}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsx)(n.p,{children:"Relying on the exact format of extern signatures is less than advisable, outside of relying on specific externs that are already known to exist."}),(0,t.jsx)(n.p,{children:"The format can be weird at the best of times and inferring attributes such as 'is this a static method' from a signature is impossible, not to mention the specifics of generics."}),(0,t.jsx)(n.p,{children:"If you are trying to make something which relies on total knowledge of the API, you will likely need to write C# code to scrape the list of Udon Graph nodes."})]}),"\n",(0,t.jsxs)(n.p,{children:["Externs have the form ",(0,t.jsx)(n.code,{children:"SomeUdonTypeName.SomeSignature"}),'. (There is one case where the Udon type name is "falsified", that being ',(0,t.jsx)(n.code,{children:"VRCInstantiate"}),".)"]}),"\n",(0,t.jsxs)(n.p,{children:["Here, the example will be ",(0,t.jsx)(n.code,{children:"SystemDateTimeOffset.__TryParseExact__SystemString_SystemStringArray_SystemIFormatProvider_SystemGlobalizationDateTimeStyles_SystemDateTimeOffsetRef__SystemBoolean"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["This is ",(0,t.jsx)(n.code,{children:"System.DateTimeOffset.TryParseExact(string, string[], System.IFormatProvider, System.Globalization.DateTimeStyles, out System.DateTimeOffset)"}),". This is a static method. It is worth noting that if it was not a static method, the 'this' parameter would still not be marked in the signature."]}),"\n",(0,t.jsxs)(n.p,{children:["The signature itself always starts with ",(0,t.jsx)(n.code,{children:"__"}),", followed by the function name, followed by ",(0,t.jsx)(n.code,{children:"__"}),". The function name is ",(0,t.jsx)(n.code,{children:"ctor"})," for constructors; here it is ",(0,t.jsx)(n.code,{children:"TryParseExact"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Each non-",(0,t.jsx)(n.code,{children:"this"})," parameter then follows as its Udon type name, separated by ",(0,t.jsx)(n.code,{children:"_"}),". There is a special modifier to the Udon type name in the case of ",(0,t.jsx)(n.code,{children:"ref"})," and ",(0,t.jsx)(n.code,{children:"out"})," parameters, that being the ",(0,t.jsx)(n.code,{children:"Ref"})," suffix."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally, the signature ends with ",(0,t.jsx)(n.code,{children:"__"})," followed by the Udon type name of the returned type."]}),"\n",(0,t.jsx)(n.p,{children:"There are some particularly weird cases:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['Generics list their type parameters as "Udon types" such as ',(0,t.jsx)(n.code,{children:"T"})," in their signature, and have invisible ",(0,t.jsx)(n.code,{children:"SystemType"})," parameters."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"VRCUdonUdonBehaviour"})," becomes ",(0,t.jsx)(n.code,{children:"VRCUdonCommonInterfacesIUdonEventReceiver"}),". (",(0,t.jsx)(n.code,{children:"Array"})," is still appended if relevant, etc.)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"There is presently no complete reference of externs."})}),"\n",(0,t.jsx)(n.p,{children:"However:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://udonsharp.docs.vrchat.com/vrchat-api",children:"The UdonSharp documentation has an API reference for the VRChat methods."})}),"\n",(0,t.jsxs)(n.li,{children:["UdonSharp provides a way to explore what's available, using the ",(0,t.jsx)(n.a,{href:"https://udonsharp.docs.vrchat.com/class-exposure-tree",children:"Class Exposure Tree"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsx)(n.p,{children:"The ability to copy member names in the UdonSharp Class Exposure Tree is broken at this time. This is a good way to quickly scout what's available, but you'll still need to actually get the extern name using Udon Graph."})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);